---
title: 浅谈浏览器基本原理和设计思想
date: 2020-08-19 21:47:45
tags:
 - 浏览器
 - 性能优化
categories: 技术
---

# 背景

做为一名前端工程师，了解浏览器工作原理，可以解决工作中遇到的大部分前端难题，并且更加深刻地理解当前的各种前端技术，不足之处和演化方向。

# 浏览器整体架构

单进程浏览器，一个进程包括了网络、Js 运行环境、渲染引擎等等，带来的问题是不稳定（一个线程崩溃整个浏览器崩溃），不安全 (浏览器插件可以获取到操作系统的任意资源。页面脚本可以通过浏览器的漏洞来获取系统权限。）

现代浏览器都是多进程架构的

1. 浏览器主进程： 负责 子进程管理，读取文件
2. 多个渲染进程：把 HTML CSS JS 转化为页面
3. GPU 进程
4. 网络进程
5. 多个插件进程

在这样的设计下，进程之间相互隔离，一个进程崩溃不会影响别的，解决了不稳定的问题，Chrome 把插件进程和渲染进程锁在沙箱里面，不能在硬盘上写入任何数据，不能获取系统权限，解决不安全的问题。

> 背景知识补充
> **进程**: CPU 资源分配的最小单位。一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。
> **线程**： CPU 调度的最小单位、线程是依附于进程的、线程之间共享内存。
> **sandbox**
> The key to security is understanding: we can only truly secure a system if we fully understand its behaviors with respect to the combination of all possible inputs in all possible states.


# 渲染流水线

刚才讲了浏览器里的一个整体架构，但是渲染流水线其实才是跟前端关系最大的，因为了解了它，能优化页面卡顿问题，提升性能。

浏览器的渲染流水线，由渲染进程，浏览器主进程，gpu 进程一起共同完成的。按照时间先后一共有八个步骤。


## 1、构建 DOM 树，依赖了渲染引擎内部一个叫 html parser的模块来完成

浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树，DOM 是一个保存在内存中树状结构，可以通过 Js 来查询或修改其内容。

## 2、样式计算

把 CSS 转换为浏览器能够理解的结构，document.styleSheets，把其中一些值例如 rem 转化为渲染引擎可以理解的标准值。通过继承规则和层叠规则计算每个 dom 节点的具体样式

## 3、布局

在DOM树上附加解释后的样式信息，生成一棵 renderObject 树，这其中，不可见的节点会被布局树忽略掉，比如 head 标签，比如 display：none 的标签。生成布局树之后，开始进行布局计算，布局计算是一个递归的过程，这是因为一个节点的大小通常需要先计算它的子节点的位置、大小等信息。

## 4、分层

页面中有很多复杂的效果，如一些复杂的 3D 变换，或者使用 z-indexing 做 z 轴排序。所以要为特定的节点生成专用的图层，生成一棵对应的图层树 renderLayer 树。相当于浏览器的页面实际上有很多图层，叠加后变成了最终的画面

- 哪些情况下 renderobject 需要建立renderlayer

1. 有层叠上下文的

position：fixed 就会创造一个层叠上下文，opacity：0.5 也会。因为要实现这些效果必须让 HTML 元素具有三维的概念。
2. 使用 canvas2d 或者 3d
3. 媒体类的 video
4. document 节点对应一个renderview节点
RenderObject树的建立并不表示DOM树会被销毁，事实上，上述图中的几个内部表示结构一直存在。


## 5、绘制

渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令组成一个待绘制列表。

## 6、分块

通常一个页面可能很大，但是用户只能看到其中的一部分，合成线程会将图层划分为图块，按照视口附近的图块来优先生成位图

## 7、光栅化

栅格化过程都会使用 GPU 来加速生成，最终位图由gpu生成，这个过程就跟相机拍一张照片一样

## 8、合成

一旦所有图块都被光栅化完成，就会给浏览器进程提交一个指令，将内存显示在屏幕上。

## 重排和重绘

如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，需要更新完整的渲染流水线，所以开销也是最大的

如果只是改颜色之类的操作，重绘可以省掉布局和分层阶段，所以执行效率会比重排操作要高一些。

# 优化

## GPU加速

比如说你用 transform 来实现动画的时候，元素就会被提到一个单独的层。它不会引起重排和重绘。操作的路径非常短

但是滥用 translate3d 反而会带来严重的性能问题：

使用3D硬件加速提升动画性能时，最好给元素增加一个z-index属性，人为干扰复合层的排序，可以有效减少chrome创建不必要的复合层，提升渲染性能，移动端优化效果尤为明显。
这种做法的原理是人为提升动画元素的z-index，让浏览器知道这个元素的层排序

从根本上来讲，gpu可以做并行运算，对图像的处理速度比cpu强。而且跑在gpu上也减轻了 cpu的开销。

# 浏览器的内存管理

v8的内存分为栈内存和堆内存。

# 栈内存垃圾回收

栈内存就是调用栈。当执行一段js代码时，会先编译，并创建执行上下文，然后再按照顺序执行代码。执行上下文会依次被压到调用栈里面。

比如说在 a 函数里面调用 b函数

执行到 b 的时候。会有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 b 的执行上下文。当它执行完了之后，JS 会将 ESP 下移到 a 函数的执行上下文，这个下移操作就是销毁 b 函数执行上下文的过程。也就是说，这个时候，虽然b函数执行上下文虽然保存在栈内存中，但是已经是无效内存。比如 a 函数又调了一个c函数，这块内容会被直接覆盖掉.

# 补充：栈内存的情况下闭包是怎么实现的

当 JavaScript 引擎执行到 a 函数时，首先会编译，并创建一个空执行上下文。

在编译过程中，遇到内部函数 b，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 a 函数中的 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在 堆空间 创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 闭包的变量。


# 堆内存垃圾回收

如果 v8 判断一个值是引用类型，不会把它放调用栈里面。而是把它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，

在 V8 中会把堆分为新生代和老生代两个区域，

# 新生代  生存时间短的对象

新生代中存放的是生存时间短的对象，这部分由副垃圾回收器回收，具体策略是，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域

当对象区域快被写满时，就需要执行一次垃圾清理操作。在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些还在被引用的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。

# 老生代  生存时间长的对象

老生代中存放的生存时间久的对象，采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收。标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。然后为了减少洞，还会有一次标记整理的过程。


## 额外知识补充： v8 为了解决垃圾回收造成的卡顿，做了增量标记

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成
